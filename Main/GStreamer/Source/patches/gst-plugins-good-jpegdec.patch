Index: ext/jpeg/gstjpegdec.c
===================================================================
--- ext/jpeg/gstjpegdec.c	Thu Jul 15 00:36:42 2010
+++ ext/jpeg/gstjpegdec.c	Thu Jul 15 00:40:54 2010
@@ -52,11 +52,13 @@
         (((struct GstJpegDecSourceMgr*)((cinfo_ptr)->src))->dec)
 
 #define JPEG_DEFAULT_IDCT_METHOD	JDCT_FASTEST
+#define JPEG_DEFAULT_ERROR_AFTER	-1
 
 enum
 {
   PROP_0,
-  PROP_IDCT_METHOD
+  PROP_IDCT_METHOD, 
+  PROP_ERROR_AFTER
 };
 
 /* *INDENT-OFF* */
@@ -190,6 +192,11 @@
       g_param_spec_enum ("idct-method", "IDCT Method",
           "The IDCT algorithm to use", GST_TYPE_IDCT_METHOD,
           JPEG_DEFAULT_IDCT_METHOD, G_PARAM_READWRITE));
+ 
+  g_object_class_install_property (gobject_class, PROP_ERROR_AFTER,
+      g_param_spec_int ("error-after", "Error After", "Error after N buffers",
+          G_MININT, G_MAXINT, JPEG_DEFAULT_ERROR_AFTER,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   gstelement_class->change_state =
       GST_DEBUG_FUNCPTR (gst_jpeg_dec_change_state);
@@ -322,6 +329,7 @@
 
   /* init properties */
   dec->idct_method = JPEG_DEFAULT_IDCT_METHOD;
+  dec->error_after = JPEG_DEFAULT_ERROR_AFTER;
 
   dec->adapter = gst_adapter_new ();
 }
@@ -1402,6 +1410,11 @@
       GST_TIME_ARGS (GST_BUFFER_DURATION (outbuf)));
 
   ret = gst_pad_push (dec->srcpad, outbuf);
+ 
+  /* reset error after counter on good buffers */
+  if (dec->error_after >= 0) {
+    dec->error_after_count = 0;
+  }
 
 skip_decoding:
 done:
@@ -1425,11 +1438,22 @@
   /* ERRORS */
 wrong_size:
   {
-    GST_ELEMENT_ERROR (dec, STREAM, DECODE,
-        ("Picture is too small or too big (%ux%u)", width, height),
-        ("Picture is too small or too big (%ux%u)", width, height));
-    ret = GST_FLOW_ERROR;
-    goto done;
+    if (dec->error_after >= 0 && (++dec->error_after_count) < dec->error_after) {
+      GST_ELEMENT_INFO (dec, STREAM, DECODE,
+          ("Picture is too small or too big (%ux%u)", width, height),
+          ("Picture is too small or too big (%ux%u)", width, height));
+      if (outbuf) {
+        gst_buffer_unref (outbuf);
+      }
+      ret = GST_FLOW_OK;
+      goto exit;
+	} else {
+      GST_ELEMENT_ERROR (dec, STREAM, DECODE,
+          ("Picture is too small or too big (%ux%u)", width, height),
+          ("Picture is too small or too big (%ux%u)", width, height));
+      ret = GST_FLOW_ERROR;
+	  goto done;
+	}
   }
 decode_error:
   {
@@ -1437,14 +1461,24 @@
 
     dec->jerr.pub.format_message ((j_common_ptr) (&dec->cinfo), err_msg);
 
-    GST_ELEMENT_ERROR (dec, STREAM, DECODE,
-        (_("Failed to decode JPEG image")), ("Error #%u: %s", code, err_msg));
-    if (outbuf) {
-      gst_buffer_unref (outbuf);
-      outbuf = NULL;
+    if (dec->error_after >= 0 && (++dec->error_after_count) < dec->error_after) {
+      GST_ELEMENT_INFO (dec, STREAM, DECODE,
+          (_("Failed to decode JPEG image")), ("Error #%u: %s", code, err_msg));
+      if (outbuf) {
+        gst_buffer_unref (outbuf);
+      }
+      ret = GST_FLOW_OK;
+      goto exit;
+	} else {
+      GST_ELEMENT_ERROR (dec, STREAM, DECODE,
+          (_("Failed to decode JPEG image")), ("Error #%u: %s", code, err_msg));
+      if (outbuf) {
+        gst_buffer_unref (outbuf);
+        outbuf = NULL;
+      }
+      ret = GST_FLOW_ERROR;
+      goto done;
     }
-    ret = GST_FLOW_ERROR;
-    goto done;
   }
 decode_direct_failed:
   {
@@ -1471,6 +1505,11 @@
   }
 drop_buffer:
   {
+    /* reset error after counter on good buffers */
+    /* not sure about this one -- should late buffers be essentially a no-op? */
+    if (dec->error_after >= 0) {
+      dec->error_after_count = 0;
+    }
     GST_WARNING_OBJECT (dec, "Outgoing buffer is outside configured segment");
     gst_buffer_unref (outbuf);
     ret = GST_FLOW_OK;
@@ -1478,10 +1517,17 @@
   }
 components_not_supported:
   {
-    GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL),
-        ("more components than supported: %d > 3", dec->cinfo.num_components));
-    ret = GST_FLOW_ERROR;
-    goto done;
+    if (dec->error_after >= 0 && (++dec->error_after_count) < dec->error_after) {
+      GST_ELEMENT_INFO (dec, STREAM, DECODE, (NULL),
+          ("more components than supported: %d > 3", dec->cinfo.num_components));
+      ret = GST_FLOW_OK;
+      goto exit;
+	} else {
+      GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL),
+          ("more components than supported: %d > 3", dec->cinfo.num_components));
+      ret = GST_FLOW_ERROR;
+      goto done;
+    }
   }
 unsupported_colorspace:
   {
@@ -1588,6 +1634,9 @@
     case PROP_IDCT_METHOD:
       dec->idct_method = g_value_get_enum (value);
       break;
+    case PROP_ERROR_AFTER:
+      dec->error_after = g_value_get_int (value);
+      break;
 
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -1607,6 +1656,9 @@
     case PROP_IDCT_METHOD:
       g_value_set_enum (value, dec->idct_method);
       break;
+    case PROP_ERROR_AFTER:
+      g_value_set_int (value, dec->error_after);
+      break;
 
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -1624,6 +1676,7 @@
 
   switch (transition) {
     case GST_STATE_CHANGE_READY_TO_PAUSED:
+      dec->error_after_count = dec->error_after;
       dec->framerate_numerator = 0;
       dec->framerate_denominator = 1;
       dec->caps_framerate_numerator = dec->caps_framerate_denominator = 0;
Index: ext/jpeg/gstjpegdec.h
===================================================================
--- ext/jpeg/gstjpegdec.h	Thu Jul 15 00:36:42 2010
+++ ext/jpeg/gstjpegdec.h	Thu Jul 15 00:41:46 2010
@@ -113,6 +113,10 @@
 
   /* properties */
   gint     idct_method;
+  gint     error_after;
+ 
+  /* number of errors we're currently at before reporting GST_FLOW_ERROR */
+  gint     error_after_count;
 
   struct jpeg_decompress_struct cinfo;
   struct GstJpegDecErrorMgr     jerr;

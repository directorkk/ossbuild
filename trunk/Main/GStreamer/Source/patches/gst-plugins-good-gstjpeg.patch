Index: gstjpegdec.c
===================================================================
--- ext/jpeg/gstjpegdec.c	(revision 686)
+++ ext/jpeg/gstjpegdec.c	(working copy)
@@ -52,11 +52,13 @@
         (((struct GstJpegDecSourceMgr*)((cinfo_ptr)->src))->dec)
 
 #define JPEG_DEFAULT_IDCT_METHOD	JDCT_FASTEST
+#define JPEG_DEFAULT_ERROR_AFTER	-1
 
 enum
 {
   PROP_0,
-  PROP_IDCT_METHOD
+  PROP_IDCT_METHOD, 
+  PROP_ERROR_AFTER
 };
 
 static GstStaticPadTemplate gst_jpeg_dec_src_pad_template =
@@ -186,6 +188,11 @@
           "The IDCT algorithm to use", GST_TYPE_IDCT_METHOD,
           JPEG_DEFAULT_IDCT_METHOD, G_PARAM_READWRITE));
 
+  g_object_class_install_property (gobject_class, PROP_ERROR_AFTER,
+      g_param_spec_int ("error-after", "Error After", "Error after N buffers",
+          G_MININT, G_MAXINT, JPEG_DEFAULT_ERROR_AFTER,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   gstelement_class->change_state =
       GST_DEBUG_FUNCPTR (gst_jpeg_dec_change_state);
 
@@ -311,6 +318,7 @@
 
   /* init properties */
   dec->idct_method = JPEG_DEFAULT_IDCT_METHOD;
+  dec->error_after = JPEG_DEFAULT_ERROR_AFTER;
 }
 
 static inline gboolean
@@ -1217,6 +1225,11 @@
 
   ret = gst_pad_push (dec->srcpad, outbuf);
 
+  /* reset error after counter on good buffers */
+  if (dec->error_after >= 0) {
+    dec->error_after_count = 0;
+  }
+
 skip_decoding:
 done:
   if (GST_BUFFER_SIZE (dec->tempbuf) == img_len) {
@@ -1248,11 +1261,22 @@
   /* ERRORS */
 wrong_size:
   {
-    GST_ELEMENT_ERROR (dec, STREAM, DECODE,
-        ("Picture is too small or too big (%ux%u)", width, height),
-        ("Picture is too small or too big (%ux%u)", width, height));
-    ret = GST_FLOW_ERROR;
-    goto done;
+    if (dec->error_after >= 0 && (++dec->error_after_count) < dec->error_after) {
+      GST_ELEMENT_INFO (dec, STREAM, DECODE,
+          ("Picture is too small or too big (%ux%u)", width, height),
+          ("Picture is too small or too big (%ux%u)", width, height));
+      if (outbuf) {
+        gst_buffer_unref (outbuf);
+      }
+      ret = GST_FLOW_OK;
+      goto exit;
+	} else {
+      GST_ELEMENT_ERROR (dec, STREAM, DECODE,
+          ("Picture is too small or too big (%ux%u)", width, height),
+          ("Picture is too small or too big (%ux%u)", width, height));
+      ret = GST_FLOW_ERROR;
+	  goto done;
+	}
   }
 decode_error:
   {
@@ -1260,14 +1284,24 @@
 
     dec->jerr.pub.format_message ((j_common_ptr) (&dec->cinfo), err_msg);
 
-    GST_ELEMENT_ERROR (dec, STREAM, DECODE,
-        (_("Failed to decode JPEG image")), ("Error #%u: %s", code, err_msg));
-    if (outbuf) {
-      gst_buffer_unref (outbuf);
-      outbuf = NULL;
+    if (dec->error_after >= 0 && (++dec->error_after_count) < dec->error_after) {
+      GST_ELEMENT_INFO (dec, STREAM, DECODE,
+          (_("Failed to decode JPEG image")), ("Error #%u: %s", code, err_msg));
+      if (outbuf) {
+        gst_buffer_unref (outbuf);
+      }
+      ret = GST_FLOW_OK;
+      goto exit;
+	} else {
+      GST_ELEMENT_ERROR (dec, STREAM, DECODE,
+          (_("Failed to decode JPEG image")), ("Error #%u: %s", code, err_msg));
+      if (outbuf) {
+        gst_buffer_unref (outbuf);
+        outbuf = NULL;
+      }
+      ret = GST_FLOW_ERROR;
+      goto done;
     }
-    ret = GST_FLOW_ERROR;
-    goto done;
   }
 decode_direct_failed:
   {
@@ -1294,6 +1328,11 @@
   }
 drop_buffer:
   {
+    /* reset error after counter on good buffers */
+    /* not sure about this one -- should late buffers be essentially a no-op? */
+    if (dec->error_after >= 0) {
+      dec->error_after_count = 0;
+    }
     GST_WARNING_OBJECT (dec, "Outgoing buffer is outside configured segment");
     gst_buffer_unref (outbuf);
     ret = GST_FLOW_OK;
@@ -1301,10 +1340,17 @@
   }
 components_not_supported:
   {
-    GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL),
-        ("more components than supported: %d > 3", dec->cinfo.num_components));
-    ret = GST_FLOW_ERROR;
-    goto done;
+    if (dec->error_after >= 0 && (++dec->error_after_count) < dec->error_after) {
+      GST_ELEMENT_INFO (dec, STREAM, DECODE, (NULL),
+          ("more components than supported: %d > 3", dec->cinfo.num_components));
+      ret = GST_FLOW_OK;
+      goto exit;
+	} else {
+      GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL),
+          ("more components than supported: %d > 3", dec->cinfo.num_components));
+      ret = GST_FLOW_ERROR;
+      goto done;
+    }
   }
 }
 
@@ -1391,6 +1437,9 @@
     case PROP_IDCT_METHOD:
       dec->idct_method = g_value_get_enum (value);
       break;
+    case PROP_ERROR_AFTER:
+      dec->error_after = g_value_get_int (value);
+      break;
 
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -1410,6 +1459,9 @@
     case PROP_IDCT_METHOD:
       g_value_set_enum (value, dec->idct_method);
       break;
+    case PROP_ERROR_AFTER:
+      g_value_set_int (value, dec->error_after);
+      break;
 
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -1427,6 +1479,7 @@
 
   switch (transition) {
     case GST_STATE_CHANGE_READY_TO_PAUSED:
+      dec->error_after_count = dec->error_after;
       dec->framerate_numerator = 0;
       dec->framerate_denominator = 1;
       dec->caps_framerate_numerator = dec->caps_framerate_denominator = 0;
Index: gstjpegdec.h
===================================================================
--- ext/jpeg/gstjpegdec.h	(revision 686)
+++ ext/jpeg/gstjpegdec.h	(working copy)
@@ -99,7 +99,11 @@
 
   /* properties */
   gint     idct_method;
+  gint     error_after;
 
+  /* number of errors we're currently at before reporting GST_FLOW_ERROR */
+  gint     error_after_count;
+
   struct jpeg_decompress_struct cinfo;
   struct GstJpegDecErrorMgr     jerr;
   struct GstJpegDecSourceMgr    jsrc;
